Для подключения Spring Context достаточно в Pom добавить 2 зависимость:

<!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>6.0.2</version>
</dependency>

<!-- https://mvnrepository.com/artifact/javax.annotation/javax.annotation-api -->
<dependency>
    <groupId>javax.annotation</groupId>                                           --Пакет аннотаций из JavaEE, в том числе @PostConstruct
    <artifactId>javax.annotation-api</artifactId>
    <version>1.3.2</version>
</dependency>


@Component
Чтобы класс стал bean, то есть управлялся SpringContext, надо добавить аннотацию @Component

@Scope()
- это правило создания объектов.
- если эту аннотацию не прописать то она добавится "по умолчанию" @Scope("singleton") // параметр с маленькой буквы,
то есть ApplicationContext создаст ТОЛЬКО ОДИН ОБЪЕКТ этого класса и будет ВСЕГДА выдавать ссылку НА НЕГО.
- @Scope("prototype") - при таком правиле при запросе ссылки на объект будет создаваться НОВЫЙ объект и возвращаться ссылка на него.
- @Scope("session") - объекты создаются на одну сессию (там еще что-то сконфигурировать надо, подробно не рассказывали)
- есть и другие, но важно либо prototype, либо singleton


@PostConstruct
- Для правильной работы ApplicationContext лучше не создавать конструкторы вообще.
- Для инициализации объектов надо создать public метод (любой) и пометить его @PostConstruct.
Это значит что после создания объектов ApplicationContext сам запустит @PostConstruct и провернет инициализацию и пр. логику, которая требуется.
- Когда же все-таки конструкторы есть и ApplicationContext всё таки в них запутался, то надо указать один из конструкторов как @Autowired,
чтобы ApplicationContext использовал именно его.


@Autowired
- Эта аннотация используется для имплементации зависимостей.
В поля, помеченные @Autowired ApplicationContext подставит ссылки на объекты внутри context соответствующих классов.
 или
В конструкторах, помеченных @Autowired ApplicationContext подставит ссылки на объекты внутри context соответствующих классов.
@Autowired можно использовать тремя образами:
    1 - над полем (не рекомендуется)
    2 - над setter-ом (предпочтительный вариант)
    3 - над конструктором (тоже не очень предпочтительный вариант, потому что сами конструкторы не рекомендуются (см. выше))
Такая политика помогает также избежать проблем с перекрестными зависимостями объектов при создании
(Ну то есть если объекту А в конструкторе нужен объект В, а объекту В нужен А - то при использовании конструкторов ApplicationContext
такие объекты НЕ создаст, а при использовании setter-ов создаст без проблем)