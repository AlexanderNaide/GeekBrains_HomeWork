Для подключения Spring Context достаточно в Pom добавить 2 зависимость:

<!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>6.0.2</version>
</dependency>

<!-- https://mvnrepository.com/artifact/javax.annotation/javax.annotation-api -->
<dependency>
    <groupId>javax.annotation</groupId>                                           --Пакет аннотаций из JavaEE, в том числе @PostConstruct
    <artifactId>javax.annotation-api</artifactId>
    <version>1.3.2</version>
</dependency>


@Component
Чтобы класс стал bean, то есть управлялся SpringContext, надо добавить аннотацию @Component

@Scope()
- это правило создания объектов.
- если эту аннотацию не прописать то она добавится "по умолчанию" @Scope("singleton") // параметр с маленькой буквы,
то есть ApplicationContext создаст ТОЛЬКО ОДИН ОБЪЕКТ этого класса и будет ВСЕГДА выдавать ссылку НА НЕГО.
- @Scope("prototype") - при таком правиле при запросе ссылки на объект будет создаваться НОВЫЙ объект и возвращаться ссылка на него.
- @Scope("session") - объекты создаются на одну сессию (там еще что-то сконфигурировать надо, подробно не рассказывали)
- есть и другие, но важно либо prototype, либо singleton


@PostConstruct
- Для правильной работы ApplicationContext лучше не создавать конструкторы вообще.
- Для инициализации объектов надо создать public метод (любой) и пометить его @PostConstruct.
Это значит что после создания объектов ApplicationContext сам запустит @PostConstruct и провернет инициализацию и пр. логику, которая требуется.
- Когда же все-таки конструкторы есть и ApplicationContext всё таки в них запутался, то надо указать один из конструкторов как @Autowired,
чтобы ApplicationContext использовал именно его.


@Autowired
- Эта аннотация используется для имплементации зависимостей.
В поля, помеченные @Autowired ApplicationContext подставит ссылки на объекты внутри context соответствующих классов.
 или
В конструкторах, помеченных @Autowired ApplicationContext подставит ссылки на объекты внутри context соответствующих классов.
@Autowired можно использовать тремя образами:
    1 - над полем (не рекомендуется)
    2 - над setter-ом (предпочтительный вариант)
    3 - над конструктором (тоже не очень предпочтительный вариант, потому что сами конструкторы не рекомендуются (см. выше))
Такая политика помогает также избежать проблем с перекрестными зависимостями объектов при создании
(Ну то есть если объекту А в конструкторе нужен объект В, а объекту В нужен А - то при использовании конструкторов ApplicationContext
такие объекты НЕ создаст, а при использовании setter-ов создаст без проблем)


@Qualifier("<...>")
- если есть неоднозначность в выборе бина.
- В случаях, когда мы в Setter-е @Autowired указываем интерфейс и несколько классов одновременно попадают под условия инициализации
ApplicationContext не будет выбирать объект какого класса ему подставить, он выдаст ошибку.
В этих случаях нужна аннотация @Qualifier перед классом объекта, она указывает, какого именно класса объект необходимо использовать.
Пример:
public void setProductRepository(@Qualifier("inMemoryProductRepository") ProductRepository productRepository){}

В кавычках используется "имя" бина. Имена, если не задать вручную, ApplicationContext генерит самостоятельно:
первая буква класса делается строчной - вот и имя. Исключение: если вторая буква тоже заглавная, тогда название класса считается аббревиатурой.
Но имя бину всегда можно устанавливать вручную:
@Component(value = "ps") - аннотация с установкой имени бину.

Аннотацию @Qualifier можно подкидывать к полю, к конструктору или к setter-у.

@Primary
- также помогает решать проблему с "неоднозначностью выбора". Если есть несколько бинов подходящих под условие,
то пометив один класс аннотацией @Primary будет выбираться именно он без дополнительного @Qualifier.
Соответственно 2 вывода:
    - нельзя два класса пометить @Primary (если они имплементируют один интерфейс или наследники одного класса, иначе опять конфликт)
    - если надо использовать не класс @Primary, а какой-то из остальных, то надо использовать @Qualifier("<...>") с явным указанием имени бина.


@Configuration
Конфигурационные классы(см. AppConfig). Таких можно делать много, потом при создании ApplicationContext
просто выбрать из какого класса мы создаем контекст (см. MainClass)
В конфигурационных классах можно указывать настройки данного ApplicationContext, а так же прописывать бины, в том числе
создавать бины из библиотечных классов (аннотация @Bean)
